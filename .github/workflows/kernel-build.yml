name: Build GKI Kernel with KernelSU and SuSFS

on:
  workflow_dispatch:
  push:
    branches:
      - main
  pull_request:
    branches:
      - main

env:
  CCACHE_DIR: /tmp/ccache
  CCACHE_MAXSIZE: 2G
  MAKE_JOBS: ${{ github.runner_arch == 'x64' && 'all' || '2' }}

jobs:
  build:
    runs-on: self-hosted
    timeout-minutes: 90

    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 1

      - name: Setup Build Environment
        run: |
          sudo apt-get update
          sudo DEBIAN_FRONTEND=noninteractive apt-get install -y \
            build-essential bc bison flex libssl-dev libelf-dev \
            libncurses5-dev git wget curl lz4 zstd python3 python3-pip \
            cpio kmod pahole pigz ninja-build patchelf xxd \
            rsync file ccache

      - name: Cache Toolchains and CCACHE
        uses: actions/cache@v4
        with:
          path: |
            ${{ github.workspace }}/toolchain
            /tmp/ccache
          key: ${{ runner.os }}-toolchains-ccache-${{ hashFiles('.github/workflows/*.yml') }}-v7
          restore-keys: |
            ${{ runner.os }}-toolchains-ccache-

      - name: Setup Custom Toolchain
        id: toolchain
        run: |
          set -e
          mkdir -p "${{ github.workspace }}/toolchain"
          cd "${{ github.workspace }}/toolchain"

          echo "üì• Downloading toolchains..."
          # Download GCC toolchains
          if [ ! -f "gcc-arm64.tar.xz" ]; then
            wget -q --show-progress -O gcc-arm64.tar.xz \
              "https://developer.arm.com/-/media/Files/downloads/gnu/14.3.rel1/binrel/arm-gnu-toolchain-14.3.rel1-x86_64-aarch64-none-linux-gnu.tar.xz"
          fi

          if [ ! -f "gcc-arm32.tar.xz" ]; then
            wget -q --show-progress -O gcc-arm32.tar.xz \
              "https://developer.arm.com/-/media/Files/downloads/gnu/14.3.rel1/binrel/arm-gnu-toolchain-14.3.rel1-x86_64-arm-none-eabi.tar.xz"
          fi

          # Handle ZyCromerZ Clang - it extracts files directly to current directory
          if [ ! -d "clang" ]; then
            echo "üì¶ Setting up ZyCromerZ Clang..."
            
            # Download the Clang release if not already downloaded
            if [ ! -f "clang.tar.gz" ]; then
              wget -q --show-progress -O clang.tar.gz \
                "https://github.com/ZyCromerZ/Clang/releases/download/22.0.0git-20250928-release/Clang-22.0.0git-20250928.tar.gz"
            fi
            
            # Extract and see what we get
            echo "Extracting ZyCromerZ Clang..."
            tar -xzf clang.tar.gz
            
            # The ZyCromerZ Clang extracts files directly to current directory
            # Let's see what was extracted and organize it properly
            echo "Contents after extraction:"
            ls -la
            
            # Create clang directory and move all extracted files into it
            mkdir -p clang
            echo "Moving extracted files to clang/ directory..."
            
            # Move all files and directories except what we don't want
            for item in *; do
              if [ "$item" != "clang" ] && [ "$item" != "clang.tar.gz" ] && \
                 [ "$item" != "gcc-arm64.tar.xz" ] && [ "$item" != "gcc-arm32.tar.xz" ] && \
                 [ "$item" != "." ] && [ "$item" != ".." ]; then
                mv "$item" clang/ 2>/dev/null || true
              fi
            done
            
            echo "Final clang directory structure:"
            ls -la clang/
            
            # Check if bin directory exists, if not create it and move binaries
            if [ ! -d "clang/bin" ]; then
              echo "Creating bin directory and organizing binaries..."
              mkdir -p clang/bin
              # Move any executable files to bin directory
              find clang -maxdepth 1 -type f -executable -exec mv {} clang/bin/ \; 2>/dev/null || true
            fi
          fi

          echo "üì¶ Extracting GCC toolchains..."
          if [ ! -d "aarch64-gcc" ]; then
            tar -xf gcc-arm64.tar.xz
            mv arm-gnu-toolchain-14.3.rel1-x86_64-aarch64-none-linux-gnu aarch64-gcc
          fi

          if [ ! -d "arm-gcc" ]; then
            tar -xf gcc-arm32.tar.xz
            mv arm-gnu-toolchain-14.3.rel1-x86_64-arm-none-eabi arm-gcc
          fi

          # Set paths - ZyCromerZ Clang might have different structure
          CLANG_BIN="$PWD/clang/bin"
          
          # If bin directory doesn't exist, try to find where the binaries are
          if [ ! -d "$CLANG_BIN" ]; then
            echo "üîç Searching for Clang binaries..."
            # Find clang binary and set path accordingly
            CLANG_PATH=$(find clang -name "clang" -type f | head -1)
            if [ -n "$CLANG_PATH" ]; then
              CLANG_BIN=$(dirname "$CLANG_PATH")
              echo "Found Clang at: $CLANG_PATH"
              echo "Setting CLANG_BIN to: $CLANG_BIN"
            else
              # If we can't find clang, try using the clang directory directly
              CLANG_BIN="$PWD/clang"
              echo "Using clang directory as CLANG_BIN: $CLANG_BIN"
            fi
          fi

          ARM64_TOOLCHAIN="$PWD/aarch64-gcc/bin/aarch64-none-linux-gnu-"
          ARM32_TOOLCHAIN="$PWD/arm-gcc/bin/arm-none-eabi-"

          # Verify everything exists
          echo "üîç Checking toolchain setup..."
          echo "CLANG_BIN: $CLANG_BIN"
          echo "ARM64_TOOLCHAIN: $ARM64_TOOLCHAIN"
          echo "ARM32_TOOLCHAIN: $ARM32_TOOLCHAIN"
          
          # List clang directory to see what we have
          echo "Clang directory contents:"
          ls -la clang/

          # Check for clang binary
          if [ -f "$CLANG_BIN/clang" ]; then
            echo "‚úÖ Clang binary found: $CLANG_BIN/clang"
          else
            # Try to find clang anywhere in the clang directory
            FOUND_CLANG=$(find clang -name "clang" -type f | head -1)
            if [ -n "$FOUND_CLANG" ]; then
              CLANG_BIN=$(dirname "$FOUND_CLANG")
              echo "‚úÖ Found Clang at: $FOUND_CLANG"
              echo "Updating CLANG_BIN to: $CLANG_BIN"
            else
              echo "‚ùå Clang binary not found in expected locations"
              echo "Searching for any executable files in clang directory:"
              find clang -type f -executable | head -10
              exit 1
            fi
          fi

          # Verify other toolchains
          for tool in "${ARM64_TOOLCHAIN}gcc" "${ARM32_TOOLCHAIN}gcc"; do
            if [ ! -f "$tool" ]; then
              echo "::error::Toolchain binary not found: $tool"
              exit 1
            fi
          done

          echo "CLANG_BIN=$CLANG_BIN" >> $GITHUB_ENV
          echo "ARM64_TOOLCHAIN=$ARM64_TOOLCHAIN" >> $GITHUB_ENV
          echo "ARM32_TOOLCHAIN=$ARM32_TOOLCHAIN" >> $GITHUB_ENV

          echo "‚úÖ ZyCromerZ Clang setup complete!"
          echo "clang version: $("$CLANG_BIN/clang" --version | head -1)"
          echo "aarch64-gcc: $("${ARM64_TOOLCHAIN}gcc" --version | head -1)"
          echo "arm-gcc: $("${ARM32_TOOLCHAIN}gcc" --version | head -1)"

      - name: Setup ccache
        run: |
          echo "$(dirname $(which ccache))" >> $GITHUB_PATH
          ccache --show-stats

      - name: Clone Kernel Source
        run: |
          if [ ! -d "kernel" ]; then
            git clone --depth=1 --branch=android14-6.1-2025-09 \
              https://android.googlesource.com/kernel/common kernel
          else
            cd kernel
            git fetch --depth=1 origin android14-6.1-2025-09
            git reset --hard origin/android14-6.1-2025-09
            cd ..
          fi

      - name: Integrate KernelSU
        run: |
          cd kernel
          for i in {1..3}; do
            if curl -LSs "https://raw.githubusercontent.com/tiann/KernelSU/main/kernel/setup.sh" | bash -s main; then
              echo "‚úÖ KernelSU integrated successfully"
              break
            fi
            echo "‚ö†Ô∏è KernelSU integration attempt $i failed, retrying..."
            sleep 10
          done

      - name: Clone and Integrate SuSFS
        run: |
          if [ ! -d "susfs" ]; then
            git clone --depth=1 --branch=gki-android14-6.1 \
              https://gitlab.com/simonpunk/susfs4ksu.git susfs
          fi
          cd kernel
          cp ../susfs/kernel_patches/fs/susfs.c fs/
          cp ../susfs/kernel_patches/include/linux/susfs.h include/linux/
          cp ../susfs/kernel_patches/include/linux/susfs_def.h include/linux/
          echo "‚úÖ SuSFS files integrated"

      - name: Apply All Patches
        id: patches
        run: |
          set +e
          cd kernel

          PATCH_BASE="https://raw.githubusercontent.com/infectedmushi/kernel_patches/refs/heads/main"

          echo "üîß Applying patches in required order..."
          
          # Apply SuSFS patches FIRST
          echo "üìã Step 1: Applying SuSFS patches..."
          
          echo "üîß Applying 10_enable_susfs_for_ksu to KernelSU/"
          curl -fsSL "$PATCH_BASE/10_enable_susfs_for_ksu.patch" -o /tmp/susfs1.patch
          cd KernelSU
          patch -p1 --forward --no-backup-if-mismatch < /tmp/susfs1.patch || echo "‚ö†Ô∏è May already be applied"
          cd ..
          rm -f /tmp/susfs1.patch

          echo "üîß Applying 50_add_susfs_in_gki-android14-6.1 to ./"
          curl -fsSL "$PATCH_BASE/50_add_susfs_in_gki-android14-6.1.patch" -o /tmp/susfs2.patch
          patch -p1 --forward --no-backup-if-mismatch < /tmp/susfs2.patch || echo "‚ö†Ô∏è May already be applied"
          rm -f /tmp/susfs2.patch

          # Apply fix patches AFTER SuSFS patches
          echo "üîß Step 2: Applying fix patches..."
          
          echo "üîß Applying fix-clidr-uninitialized to ./"
          curl -fsSL "$PATCH_BASE/fix-clidr-uninitialized.patch" -o /tmp/fix1.patch
          patch -p1 --forward --no-backup-if-mismatch < /tmp/fix1.patch || echo "‚ö†Ô∏è May already be applied"
          rm -f /tmp/fix1.patch

          echo "üîß Applying fix_proc_base to ./"
          curl -fsSL "$PATCH_BASE/fix_proc_base.patch" -o /tmp/fix2.patch
          patch -p1 --forward --no-backup-if-mismatch < /tmp/fix2.patch || echo "‚ö†Ô∏è May already be applied"
          rm -f /tmp/fix2.patch

          set -e
          echo "üéâ All patches applied in correct order (SuSFS first, then fixes)!"
      - name: Configure Kernel
        id: config
        run: |
          cd kernel
          export ARCH=arm64
          export SUBARCH=arm64

          # Setup environment
          export PATH="$CLANG_BIN:$PATH"
          export CROSS_COMPILE="$ARM64_TOOLCHAIN"
          export CROSS_COMPILE_COMPAT="$ARM32_TOOLCHAIN"

          echo "‚öôÔ∏è Setting up kernel configuration..."
          
          # First generate base GKI config
          echo "üîß Generating base GKI config..."
          make ARCH=arm64 LLVM=1 LLVM_IAS=1 LD=ld.lld O=out gki_defconfig

          # Now append all your customizations directly to the .config file
          echo "üîß Applying custom configurations..."
          cat >> out/.config << 'EOF'
          CONFIG_ARM64_CORTEX_X3=y
          CONFIG_ARM64_CORTEX_A715=y
          CONFIG_ARM64_CORTEX_A510=y
          CONFIG_ARM64_VA_BITS=48
          CONFIG_ARM64_PA_BITS=48
          CONFIG_ARM64_TAGGED_ADDR_ABI=y
          CONFIG_ARM64_SVE=y
          CONFIG_ARM64_BTI=y
          CONFIG_ARM64_PTR_AUTH=y
          CONFIG_ARM64_SME=y
          CONFIG_SCHED_MC=y
          CONFIG_SCHED_CORE=y
          CONFIG_ENERGY_MODEL=y
          CONFIG_UCLAMP_TASK=y
          CONFIG_UCLAMP_TASK_GROUP=y
          CONFIG_SCHEDUTIL=y
          CONFIG_CPU_FREQ=y
          CONFIG_CPUFREQ_DT=y
          CONFIG_CPU_FREQ_GOV_SCHEDUTIL=y
          CONFIG_CPU_FREQ_DEFAULT_GOV_SCHEDUTIL=y
          CONFIG_OPP=y
          CONFIG_CPU_IDLE=y
          CONFIG_ARM_PSCI_CPUIDLE=y
          CONFIG_THERMAL=y
          CONFIG_CPU_THERMAL=y
          CONFIG_DEVFREQ_THERMAL=y
          CONFIG_THERMAL_GOV_POWER_ALLOCATOR=y
          CONFIG_THERMAL_GOV_STEP_WISE=y
          CONFIG_THERMAL_GOV_FAIR_SHARE=y
          CONFIG_THERMAL_EMULATION=y
          CONFIG_THERMAL_WRITABLE_TRIPS=y
          CONFIG_POWER_CAP=y
          CONFIG_PERF_EVENTS=y
          CONFIG_NUMA_BALANCING=y
          CONFIG_CMA=y
          CONFIG_CMA_AREAS=7
          CONFIG_LOCALVERSION_AUTO=n
          CONFIG_KSU=y
          CONFIG_KSU_LSM_SECURITY_HOOKS=y
          CONFIG_KSU_SUSFS=y
          CONFIG_KSU_SUSFS_SUS_PATH=y
          CONFIG_KSU_SUSFS_SUS_MOUNT=y
          CONFIG_KSU_SUSFS_SUS_KSTAT=y
          CONFIG_KSU_SUSFS_TRY_UMOUNT=y
          CONFIG_KSU_SUSFS_SPOOF_UNAME=y
          CONFIG_KSU_SUSFS_ENABLE_LOG=y
          CONFIG_KSU_SUSFS_HIDE_KSU_SUSFS_SYMBOLS=y
          CONFIG_KSU_SUSFS_SPOOF_CMDLINE_OR_BOOTCONFIG=y
          CONFIG_KSU_SUSFS_OPEN_REDIRECT=y
          CONFIG_KSU_SUSFS_SUS_MAP=y
          CONFIG_TMPFS_XATTR=y
          CONFIG_TMPFS_POSIX_ACL=y
          CONFIG_IP_NF_TARGET_TTL=y
          CONFIG_IP6_NF_TARGET_HL=y
          CONFIG_IP6_NF_MATCH_HL=y
          CONFIG_TCP_CONG_ADVANCED=y
          CONFIG_TCP_CONG_BBR=y
          CONFIG_NET_SCH_FQ=y
          CONFIG_TCP_CONG_BIC=n
          CONFIG_TCP_CONG_WESTWOOD=n
          CONFIG_TCP_CONG_HTCP=n
          CONFIG_CC_OPTIMIZE_FOR_PERFORMANCE=y
          CONFIG_CC_FLAGS="-O3 -flto -ffunction-sections -fdata-sections"
          CONFIG_CCACHE=y
          CONFIG_LTO=y
          CONFIG_LTO_CLANG=y
          CONFIG_LTO_CLANG_THIN=y
          CONFIG_IP_SET=y
          CONFIG_IP_SET_MAX=256
          CONFIG_IP_SET_BITMAP_IP=y
          CONFIG_IP_SET_BITMAP_IPMAC=y
          CONFIG_IP_SET_BITMAP_PORT=y
          CONFIG_IP_SET_HASH_IP=y
          CONFIG_IP_SET_HASH_IPPORT=y
          CONFIG_IP_SET_HASH_IPPORTIP=y
          CONFIG_IP_SET_HASH_IPPORTNET=y
          CONFIG_IP_SET_HASH_NET=y
          CONFIG_IP_SET_HASH_NETNET=y
          CONFIG_IP_SET_HASH_NETPORT=y
          CONFIG_IP_SET_HASH_NETIFACE=y
          CONFIG_LOCALVERSION="-deepongi"
          EOF

          # Remove ABI exports for WiFi fix
          rm -vf android/abi_gki_protected_exports_* || true

          # Final config generation to resolve dependencies
          echo "üîß Resolving config dependencies..."
          make ARCH=arm64 LLVM=1 LLVM_IAS=1 LD=ld.lld O=out olddefconfig

          echo "‚úÖ Kernel configuration complete"
          echo "üìã Final config summary:"
          grep -E "CONFIG_(KSU|SUSFS|LTO|LOCALVERSION)" out/.config | head -20
          
      - name: Build Kernel
        id: build
        continue-on-error: false
        run: |
          cd kernel
          export ARCH=arm64
          export SUBARCH=arm64

          # Setup build environment
          export PATH="$CLANG_BIN:$PATH"
          export CROSS_COMPILE="$ARM64_TOOLCHAIN" 
          export CROSS_COMPILE_COMPAT="$ARM32_TOOLCHAIN"

          # Simple build timestamp
          export KBUILD_BUILD_TIMESTAMP="$(date -u '+%Y-%m-%d %H:%M:%S UTC')"
          export KBUILD_BUILD_USER=github-actions
          export KBUILD_BUILD_HOST=github

          echo "üèóÔ∏è Starting kernel build with $(nproc) cores..."
          echo "üìä CCACHE stats before build:"
          ccache -s

          START_TIME=$SECONDS

          # Build with normal output (shows file compilation progress)
          echo "üîß Building with full compilation output..."
          make -j$(nproc) \
            LLVM_IAS=1 \
            LLVM=1 \
            ARCH=arm64 \
            CLANG_TRIPLE=aarch64-linux-gnu- \
            CROSS_COMPILE_COMPAT="$ARM32_TOOLCHAIN" \
            CROSS_COMPILE="$ARM64_TOOLCHAIN" \
            CC="ccache clang" \
            LD=ld.lld \
            HOSTLD=ld.lld \
            O=out \
            2>&1 | tee build.log

          BUILD_STATUS=${PIPESTATUS[0]}
          BUILD_TIME=$((SECONDS - START_TIME))

          echo "üìä CCACHE stats after build:"
          ccache -s

          if [ $BUILD_STATUS -eq 0 ] && [ -f out/arch/arm64/boot/Image ]; then
            echo "‚úÖ Kernel built successfully in ${BUILD_TIME}s"
            echo "BUILD_TIME=$BUILD_TIME" >> $GITHUB_ENV
            echo "BUILD_STATUS=success" >> $GITHUB_ENV
          else
            echo "‚ùå Kernel build failed after ${BUILD_TIME}s"
            echo "BUILD_TIME=$BUILD_TIME" >> $GITHUB_ENV  
            echo "BUILD_STATUS=failed" >> $GITHUB_ENV
            exit 1
          fi

      - name: Upload Build Log on Failure
        if: failure() && steps.build.outcome == 'failure'
        uses: actions/upload-artifact@v4
        with:
          name: build-failure-logs-${{ github.run_number }}
          path: |
            kernel/build.log
            kernel/out/.config
          retention-days: 30

      - name: Prepare AnyKernel3
        if: success()
        run: |
          git clone --depth=1 --branch=KernelSU \
            https://github.com/deepongi-labs/AnyKernel3-p8a AnyKernel3
          cd AnyKernel3
          rm -rf .git .github

          # Copy kernel artifacts - using Image instead of Image.gz
          cp ../kernel/out/arch/arm64/boot/Image ./
          [ -f ../kernel/out/arch/arm64/boot/dtbo.img ] && cp ../kernel/out/arch/arm64/boot/dtbo.img ./
          [ -f ../kernel/out/arch/arm64/boot/dtb ] && cp ../kernel/out/arch/arm64/boot/dtb ./

          # Add build info
          echo "build.date=$(date -u +%Y-%m-%d)" > build.info
          echo "build.commit=${{ github.sha }}" >> build.info
          echo "build.run=${{ github.run_number }}" >> build.info

          echo "‚úÖ AnyKernel3 prepared with uncompressed Image"
      - name: Package Kernel
        if: success()
        run: |
          cd AnyKernel3
          KERNEL_VERSION="6.1.145"
          TIMESTAMP=$(date +%Y%m%d_%H%M)
          ZIP_NAME="GKI-KernelSU-SuSFS-${KERNEL_VERSION}-${TIMESTAMP}.zip"

          # Create flashable zip
          zip -r9 "../$ZIP_NAME" . -x "*.git*" "README.md" ".github/*"

          # Generate checksums
          cd ..
          sha256sum "$ZIP_NAME" > "${ZIP_NAME}.sha256"
          md5sum "$ZIP_NAME" > "${ZIP_NAME}.md5"

          echo "KERNEL_ZIP=$ZIP_NAME" >> $GITHUB_ENV
          
          echo "üì¶ Package created: $ZIP_NAME ($(du -h $ZIP_NAME | cut -f1))"
          echo "üìÑ SHA256: $(cat ${ZIP_NAME}.sha256)"
          echo "üìÑ MD5: $(cat ${ZIP_NAME}.md5)"

      - name: Upload Kernel Artifacts
        if: success()
        uses: actions/upload-artifact@v4
        with:
          name: kernel-build-${{ github.run_number }}
          path: |
            ${{ env.KERNEL_ZIP }}
            ${{ env.KERNEL_ZIP }}.sha256
            ${{ env.KERNEL_ZIP }}.md5
          retention-days: 30

      - name: Create Release
        if: success() && github.event_name == 'push' && github.ref == 'refs/heads/main'
        uses: softprops/action-gh-release@v1
        with:
          tag_name: build-${{ github.run_number }}
          name: "Kernel Build #${{ github.run_number }}"
          body: |
            ## üöÄ GKI Kernel with KernelSU & SuSFS
            **Build #${{ github.run_number }}** ‚Ä¢ $(date -u +%Y-%m-%d)
            ### üìä Build Info
            - **Duration:** ${{ env.BUILD_TIME }} seconds
            - **Kernel:** 6.1.145
          files: |
            ${{ env.KERNEL_ZIP }}
            ${{ env.KERNEL_ZIP }}.sha256
            ${{ env.KERNEL_ZIP }}.md5
        env:
          GITHUB_TOKEN: ${{ secrets.RELEASE_TOKEN }}  # Use PAT instead of GITHUB_TOKEN
